#!/bin/bash

# AI Language Learning Platform - Development Startup Script

echo "ðŸš€ Starting AI Language Learning Platform..."

# Check if we're in the right directory
if [ ! -f "server/requirements.txt" ] || [ ! -f "client/package.json" ]; then
    echo "âŒ Error: Please run this script from the project root directory (AI Language Learning Platform)"
    exit 1
fi

# Absolute project root
PROJECT_ROOT="$(pwd)"

create_backend_venv() {
    echo "ðŸ› ï¸  Setting up backend virtual environment..."
    pushd "$PROJECT_ROOT/server" >/dev/null || exit 1
    python3 -m venv venv
    source venv/bin/activate
    pip install --upgrade pip
    pip install -r requirements.txt uvicorn flask_sqlalchemy
    deactivate
    popd >/dev/null || exit 1
}

ensure_backend_env() {
    # Create venv if it doesn't exist
    if [ ! -d "$PROJECT_ROOT/server/venv" ]; then
        create_backend_venv
    fi
    # Ensure key packages are installed
    source "$PROJECT_ROOT/server/venv/bin/activate"
    python - <<'PY'
import pkg_resources, sys
required = {"uvicorn", "flask_sqlalchemy"}
missing = [pkg for pkg in required if pkg not in {p.key for p in pkg_resources.working_set}]
if missing:
    import subprocess, sys
    subprocess.check_call([sys.executable, "-m", "pip", "install", *missing])
PY
    deactivate
}

# Function to start backend
start_backend() {
    echo "ðŸ”§ Starting backend server..."
    ensure_backend_env
    pushd "$PROJECT_ROOT/server" >/dev/null || exit 1
    source venv/bin/activate
    python -m uvicorn app.main_simple:app --reload --host 0.0.0.0 --port 8000 &
    BACKEND_PID=$!
    popd >/dev/null || exit 1
}

# Function to start frontend
start_frontend() {
    echo "ðŸŽ¨ Starting frontend development server..."
    pushd "$PROJECT_ROOT/client" >/dev/null || exit 1
    npm install --legacy-peer-deps --silent
    npm run dev &
    FRONTEND_PID=$!
    popd >/dev/null || exit 1
}

# Environment setup function
setup_environment_files() {
    echo "ðŸ”§ Checking and setting up environment files..."
    
    # Setup server environment
    if [ ! -f "server/.env" ]; then
        echo "ðŸ“„ Creating server/.env from server/env.example..."
        if [ -f "server/env.example" ]; then
            cp "server/env.example" "server/.env"
            echo "âœ… Server environment file created"
        else
            echo "âŒ Warning: server/env.example not found"
        fi
    else
        echo "âœ… Server environment file exists"
    fi
    
    # Setup client environment with proper localhost configuration
    if [ ! -f "client/.env.local" ]; then
        echo "ðŸ“„ Creating client/.env.local from client/.env.example..."
        if [ -f "client/.env.example" ]; then
            cp "client/.env.example" "client/.env.local"
            echo "âœ… Client environment file created"
        else
            echo "ðŸ“„ Creating minimal client/.env.local..."
            cat > "client/.env.local" << 'EOF'
# AI Language Learning Platform - Local Development Configuration
# Auto-generated by start-development.sh

# API Configuration - Use localhost for consistent networking
NEXT_PUBLIC_API_BASE_URL=http://localhost:8000
NEXT_PUBLIC_WS_BASE_URL=ws://localhost:8000

# Environment
NEXT_PUBLIC_ENVIRONMENT=development
NEXT_PUBLIC_ENABLE_DEBUG_LOGS=true

# Features
NEXT_PUBLIC_ENABLE_V0_INTEGRATION=true
NEXT_PUBLIC_ENABLE_AI_CHAT=true

# Analytics (optional)
NEXT_PUBLIC_ANALYTICS_ID=""
EOF
            echo "âœ… Client environment file created with defaults"
        fi
    else
        echo "âœ… Client environment file exists"
        
        # Validate that the environment file has the correct API URL
        if ! grep -q "NEXT_PUBLIC_API_BASE_URL=http://localhost:8000" "client/.env.local"; then
            echo "ðŸ”„ Updating API URL to use localhost..."
            
            # Create backup
            cp "client/.env.local" "client/.env.local.backup.$(date +%s)"
            
            # Update or add the API URL
            if grep -q "NEXT_PUBLIC_API_BASE_URL=" "client/.env.local"; then
                sed -i.tmp 's|NEXT_PUBLIC_API_BASE_URL=.*|NEXT_PUBLIC_API_BASE_URL=http://localhost:8000|' "client/.env.local"
                rm -f "client/.env.local.tmp"
            else
                echo "NEXT_PUBLIC_API_BASE_URL=http://localhost:8000" >> "client/.env.local"
            fi
            
            # Update or add the WS URL
            if grep -q "NEXT_PUBLIC_WS_BASE_URL=" "client/.env.local"; then
                sed -i.tmp 's|NEXT_PUBLIC_WS_BASE_URL=.*|NEXT_PUBLIC_WS_BASE_URL=ws://localhost:8000|' "client/.env.local"
                rm -f "client/.env.local.tmp"
            else
                echo "NEXT_PUBLIC_WS_BASE_URL=ws://localhost:8000" >> "client/.env.local"
            fi
            
            echo "âœ… Environment URLs updated to use localhost"
        fi
    fi
}

# Call environment setup
setup_environment_files

# Connectivity validation function
validate_backend_connectivity() {
    echo "ðŸ” Validating backend connectivity..."
    local max_attempts=30
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if curl -s -f "http://localhost:8000/health" >/dev/null 2>&1; then
            echo "âœ… Backend is responding at http://localhost:8000"
            return 0
        fi
        
        if [ $attempt -eq 1 ]; then
            echo "â³ Waiting for backend to start..."
        elif [ $((attempt % 5)) -eq 0 ]; then
            echo "â³ Still waiting... (attempt $attempt/$max_attempts)"
        fi
        
        sleep 1
        attempt=$((attempt + 1))
    done
    
    echo "âŒ Backend failed to respond after $max_attempts seconds"
    echo "ðŸ’¡ Troubleshooting tips:"
    echo "   - Check if port 8000 is already in use: lsof -i :8000"
    echo "   - Ensure Python virtual environment is set up correctly"
    echo "   - Check server logs for errors"
    return 1
}

# Start services based on argument
case "${1:-both}" in
    "backend")
        start_backend
        wait $BACKEND_PID
        ;;
    "frontend")
        start_frontend
        wait $FRONTEND_PID
        ;;
    "both")
        echo "ðŸ“‹ Starting both backend and frontend..."
        echo "   Backend â†’ http://localhost:8000"
        echo "   Frontend â†’ http://localhost:3000"
        echo "   Press Ctrl+C to stop."

        start_backend
        
        # Wait for backend to be ready before starting frontend
        if validate_backend_connectivity; then
            echo "ðŸš€ Starting frontend..."
            start_frontend
            echo ""
            echo "ðŸŽ‰ Development environment is ready!"
            echo "   ðŸ“Š Backend API: http://localhost:8000"
            echo "   ðŸŒ Frontend App: http://localhost:3000"
            echo "   ðŸ“– API Health: http://localhost:8000/health"
            echo ""
        else
            echo "âŒ Failed to start backend, skipping frontend startup"
            echo "ðŸ›‘ Stopping backend process..."
            kill $BACKEND_PID 2>/dev/null || true
            exit 1
        fi

        wait $BACKEND_PID $FRONTEND_PID
        ;;
    *)
        echo "Usage: $0 [backend|frontend|both]"
        exit 1
        ;;
esac 