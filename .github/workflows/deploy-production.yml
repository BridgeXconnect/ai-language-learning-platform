name: Deploy to Production

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - production-hotfix

jobs:
  deploy-production:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: ./client/package-lock.json
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: Build and tag images
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ai-language-learning-platform
        IMAGE_TAG: production-${{ github.sha }}
      run: |
        # Build with production optimizations
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY-client:$IMAGE_TAG \
          --build-arg NODE_ENV=production \
          --build-arg NEXT_PUBLIC_API_URL=${{ secrets.PRODUCTION_API_URL }} \
          ./client
        
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY-server:$IMAGE_TAG \
          --build-arg ENVIRONMENT=production \
          ./server
        
        # Build agents
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY-orchestrator:$IMAGE_TAG ./agents/orchestrator
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY-course-planner:$IMAGE_TAG ./agents/course-planner
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY-content-creator:$IMAGE_TAG ./agents/content-creator
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY-quality-assurance:$IMAGE_TAG ./agents/quality-assurance
    
    - name: Run comprehensive security scan
      run: |
        # Install Trivy
        sudo apt-get update
        sudo apt-get install wget apt-transport-https gnupg lsb-release
        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
        echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
        sudo apt-get update
        sudo apt-get install trivy
        
        # Scan all images - fail on HIGH/CRITICAL
        trivy image --exit-code 1 --severity HIGH,CRITICAL $ECR_REGISTRY/$ECR_REPOSITORY-server:production-${{ github.sha }}
        trivy image --exit-code 1 --severity HIGH,CRITICAL $ECR_REGISTRY/$ECR_REPOSITORY-client:production-${{ github.sha }}
    
    - name: Push images to ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ai-language-learning-platform
        IMAGE_TAG: production-${{ github.sha }}
      run: |
        docker push $ECR_REGISTRY/$ECR_REPOSITORY-client:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY-server:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY-orchestrator:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY-course-planner:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY-content-creator:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY-quality-assurance:$IMAGE_TAG
        
        # Tag as latest
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY-client:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY-client:latest
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY-server:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY-server:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY-client:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY-server:latest
    
    - name: Create database backup
      run: |
        aws rds create-db-snapshot \
          --db-instance-identifier ai-language-learning-production \
          --db-snapshot-identifier production-backup-$(date +%Y%m%d-%H%M%S) \
          --region ${{ secrets.AWS_REGION }}
    
    - name: Deploy to EKS with Blue-Green
      run: |
        aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ai-language-learning-production
        
        # Update deployment manifests
        sed -i "s|IMAGE_TAG|production-${{ github.sha }}|g" k8s/production/*.yaml
        sed -i "s|ECR_REGISTRY|${{ steps.login-ecr.outputs.registry }}|g" k8s/production/*.yaml
        
        # Blue-Green deployment strategy
        kubectl apply -f k8s/production/
        
        # Wait for new deployments to be ready
        kubectl rollout status deployment/client-deployment -n production --timeout=600s
        kubectl rollout status deployment/server-deployment -n production --timeout=600s
        kubectl rollout status deployment/orchestrator-deployment -n production --timeout=600s
        kubectl rollout status deployment/course-planner-deployment -n production --timeout=600s
        kubectl rollout status deployment/content-creator-deployment -n production --timeout=600s
        kubectl rollout status deployment/quality-assurance-deployment -n production --timeout=600s
    
    - name: Run production health checks
      run: |
        # Wait for services to be fully ready
        sleep 180
        
        # Get production endpoint
        PRODUCTION_URL=$(kubectl get service client-service -n production -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        
        # Comprehensive health checks
        curl -f $PRODUCTION_URL/health || exit 1
        curl -f $PRODUCTION_URL/api/health || exit 1
        curl -f $PRODUCTION_URL/api/agents/health || exit 1
        
        # Run critical path tests
        npm install -g newman
        newman run postman/production-tests.json --env-var baseUrl=$PRODUCTION_URL
        
        # Performance baseline test
        npm install -g lighthouse
        lighthouse $PRODUCTION_URL --output=json --output-path=./lighthouse-report.json
        
        # Check performance score
        PERFORMANCE_SCORE=$(cat lighthouse-report.json | jq '.categories.performance.score * 100')
        if [ $PERFORMANCE_SCORE -lt 80 ]; then
          echo "‚ùå Performance score too low: $PERFORMANCE_SCORE"
          exit 1
        fi
    
    - name: Update monitoring and alerting
      run: |
        # Update Prometheus monitoring
        kubectl apply -f k8s/monitoring/
        
        # Update Grafana dashboards
        curl -X POST \
          -H "Authorization: Bearer ${{ secrets.GRAFANA_API_KEY }}" \
          -H "Content-Type: application/json" \
          -d @monitoring/grafana-dashboard.json \
          "${{ secrets.GRAFANA_URL }}/api/dashboards/db"
        
        # Update PagerDuty alerts
        curl -X POST \
          -H "Authorization: Token token=${{ secrets.PAGERDUTY_API_KEY }}" \
          -H "Content-Type: application/json" \
          -d @monitoring/pagerduty-alerts.json \
          "https://api.pagerduty.com/services/${{ secrets.PAGERDUTY_SERVICE_ID }}/integrations"
    
    - name: Create deployment record
      run: |
        # Create deployment record in database
        curl -X POST \
          -H "Authorization: Bearer ${{ secrets.DEPLOYMENT_API_KEY }}" \
          -H "Content-Type: application/json" \
          -d '{
            "version": "production-${{ github.sha }}",
            "deployed_at": "'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'",
            "deployed_by": "${{ github.actor }}",
            "commit_sha": "${{ github.sha }}",
            "environment": "production"
          }' \
          "${{ secrets.DEPLOYMENT_API_URL }}/deployments"
    
    - name: Rollback on failure
      if: failure()
      run: |
        echo "‚ùå Production deployment failed - initiating rollback"
        
        # Rollback deployments
        kubectl rollout undo deployment/client-deployment -n production
        kubectl rollout undo deployment/server-deployment -n production
        kubectl rollout undo deployment/orchestrator-deployment -n production
        kubectl rollout undo deployment/course-planner-deployment -n production
        kubectl rollout undo deployment/content-creator-deployment -n production
        kubectl rollout undo deployment/quality-assurance-deployment -n production
        
        # Wait for rollback to complete
        kubectl rollout status deployment/client-deployment -n production
        kubectl rollout status deployment/server-deployment -n production
        
        # Notify on-call team
        curl -X POST \
          -H "Authorization: Token token=${{ secrets.PAGERDUTY_API_KEY }}" \
          -H "Content-Type: application/json" \
          -d '{
            "incident": {
              "type": "incident",
              "title": "Production deployment failed - rollback initiated",
              "service": {
                "id": "${{ secrets.PAGERDUTY_SERVICE_ID }}",
                "type": "service_reference"
              },
              "body": {
                "type": "incident_body",
                "details": "Production deployment failed for commit ${{ github.sha }}. Automatic rollback initiated."
              }
            }
          }' \
          "https://api.pagerduty.com/incidents"
    
    - name: Notify teams
      if: always()
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#production-deployments'
        message: |
          üöÄ Production deployment ${{ job.status }}
          üîó Production URL: https://$PRODUCTION_URL
          üìä Commit: ${{ github.sha }}
          üë§ Author: ${{ github.actor }}
          ‚è∞ Deployed: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
    
    - name: Create GitHub release
      if: success()
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: production-${{ github.sha }}
        release_name: Production Release ${{ github.sha }}
        body: |
          ## Production Deployment
          
          **Commit:** ${{ github.sha }}
          **Author:** ${{ github.actor }}
          **Deployed:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          ### Changes
          ${{ github.event.head_commit.message }}
          
          ### Deployment Details
          - **Environment:** Production
          - **Image Tag:** production-${{ github.sha }}
          - **Health Checks:** ‚úÖ Passed
          - **Performance Score:** $PERFORMANCE_SCORE/100
        draft: false
        prerelease: false